<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Real-time Surveillance Dashboard</title>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: #0a0a0a;
        color: #e0e0e0;
        overflow: hidden;
    }
    
    .dashboard {
        display: grid;
        grid-template-columns: 1fr 400px;
        grid-template-rows: 60px 1fr;
        height: 100vh;
        gap: 1px;
        background: #333;
    }
    
    .header {
        grid-column: 1 / -1;
        background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 2rem;
        border-bottom: 2px solid #667eea;
    }
    
    h1 {
        font-size: 1.5rem;
        font-weight: 300;
        letter-spacing: 2px;
        color: #667eea;
    }
    
    .controls {
        display: flex;
        gap: 1rem;
        align-items: center;
    }
    
    button {
        padding: 0.5rem 1.5rem;
        border: 1px solid #667eea;
        background: transparent;
        color: #667eea;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 500;
    }
    
    button:hover {
        background: #667eea;
        color: #000;
        transform: translateY(-2px);
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .status-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: #1a1a1a;
        border-radius: 20px;
    }
    
    .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        animation: pulse 2s infinite;
    }
    
    .status-dot.active {
        background: #10b981;
    }
    
    .status-dot.inactive {
        background: #ef4444;
        animation: none;
    }
    
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }
    
    .video-section {
        background: #1a1a1a;
        display: flex;
        flex-direction: column;
        padding: 1rem;
    }
    
    .video-container {
        flex: 1;
        position: relative;
        background: #000;
        border-radius: 10px;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    #videoFeed {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
    
    .video-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
    }
    
    .detection-box {
        position: absolute;
        border: 2px solid #10b981;
        background: rgba(16, 185, 129, 0.1);
        transition: all 0.3s ease;
    }
    
    .detection-label {
        position: absolute;
        top: -25px;
        left: 0;
        background: #10b981;
        color: #000;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: 600;
        white-space: nowrap;
    }
    
    .sidebar {
        background: #1a1a1a;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    .sidebar-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        border-bottom: 1px solid #333;
        overflow: hidden;
    }
    
    .section-header {
        padding: 1rem;
        background: #2d2d2d;
        font-weight: 600;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .section-content {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
    }
    
    .alert-item {
        background: #2d2d2d;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 0.5rem;
        border-left: 4px solid #ef4444;
        animation: slideIn 0.3s ease;
    }
    
    .alert-item.low {
        border-left-color: #f59e0b;
    }
    
    .alert-item.medium {
        border-left-color: #f59e0b;
    }
    
    .alert-item.high {
        border-left-color: #ef4444;
    }
    .alert-item.critical {
    border-left-color: #dc3545;
    background: #f8d7da;
    }

    .no-plate-alert {
        background: #dc3545;
        color: white;
        padding: 1rem;
        margin-bottom: 1rem;
        border-radius: 8px;
        font-weight: 600;
        animation: pulse 2s infinite;
    }
    
    @keyframes slideIn {
        from {
            transform: translateX(20px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    .alert-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 0.5rem;
    }
    
    .alert-type {
        font-weight: 600;
        color: #f59e0b;
    }
    
    .alert-time {
        font-size: 0.8rem;
        color: #888;
    }
    
    .detection-item {
        background: #2d2d2d;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 0.5rem;
        display: flex;
        gap: 1rem;
        align-items: center;
        animation: slideIn 0.3s ease;
    }
    
    .detection-image {
        width: 80px;
        height: 40px;
        object-fit: cover;
        border-radius: 4px;
    }
    
    .detection-info {
        flex: 1;
    }
    
    .plate-text {
        font-size: 1.2rem;
        font-weight: 600;
        color: #667eea;
        margin-bottom: 0.25rem;
    }
    
    .confidence {
        font-size: 0.9rem;
        color: #888;
    }
    
    .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
    }
    
    .stat-item {
        background: #2d2d2d;
        padding: 1rem;
        border-radius: 8px;
        text-align: center;
    }
    
    .stat-value {
        font-size: 1.5rem;
        font-weight: 700;
        color: #667eea;
    }
    
    .stat-label {
        font-size: 0.8rem;
        color: #888;
        margin-top: 0.25rem;
    }
    
    .back-link {
        text-decoration: none;
        color: #667eea;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .back-link:hover {
        color: #8b9ff5;
    }
    
    .no-video {
        color: #888;
        font-size: 1.2rem;
    }
    
    .connection-error {
        background: #ef4444;
        color: white;
        padding: 1rem;
        text-align: center;
        position: fixed;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        border-radius: 8px;
        z-index: 1000;
    }
</style>
</head>
<body>
    <div class="dashboard">
        <header class="header">
            <div style="display: flex; align-items: center; gap: 1rem;">
                <a href="index.html" class="back-link">
                    ‚Üê Back to Home
                </a>
                <a href="session_history.html" class="back-link" style="background: #b8b8b84b;">
                    Session History
                </a>
            </div>
            <h1>REAL-TIME SURVEILLANCE</h1>
            <div class="controls">
                <div class="status-indicator">
                    <div class="status-dot inactive" id="statusDot"></div>
                    <span id="statusText">Disconnected</span>
                </div>
                <span id="fpsDisplay" style="color: #10b981; margin: 0 1rem;">0.0 FPS</span>
                <select id="videoSource">
                    <option value="0">Default Camera</option>
                </select>
                <button id="startBtn" onclick="startSurveillance()">Start Surveillance</button>
                <button id="stopBtn" onclick="stopSurveillance()" disabled>Stop</button>
                <button onclick="resetCameraPermissions()" style="background: #ef4444;">Reset Camera</button>
            </div>
        </header>
        
        <div class="video-section">
            <div class="video-container">
                <video id="videoFeed" style="display: none;" autoplay muted></video>
                <canvas id="overlayCanvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
                <div class="no-video" id="noVideo">
                    Click "Start Surveillance" to begin monitoring
                </div>
            </div>
        </div>
        
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="section-header">
                    <span>Anomaly Alerts</span>
                    <span id="alertCount">0</span>
                </div>
                <div class="section-content" id="alertsList"></div>
            </div>
            
            <div class="sidebar-section">
                <div class="section-header">
                    <span>Recent Detections</span>
                    <span id="detectionCount">0</span>
                </div>
                <div class="section-content" id="detectionsList"></div>
            </div>
            
            <div class="sidebar-section">
                <div class="section-header">
                    <span>Statistics</span>
                </div>
                <div class="section-content">
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="totalVehicles">0</div>
                            <div class="stat-label">Vehicles Tracked</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalDetections">0</div>
                            <div class="stat-label">Total Detections</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="alertsToday">0</div>
                            <div class="stat-label">Alerts Today</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="avgConfidence">0%</div>
                            <div class="stat-label">Avg Confidence</div>
                        </div>
                    </div>
                </div>
            </div>
        </aside>
    </div>
    
    <div class="connection-error" id="connectionError" style="display: none;">
        ‚ö†Ô∏è Connection lost. Attempting to reconnect...
    </div>

    <script>
        let ws = null;
        let isConnected = false;
        let alerts = [];
        let detections = [];
        let stats = {
            totalVehicles: 0,
            totalDetections: 0,
            alertsToday: 0,
            avgConfidence: 0
        };
        
        // Camera handling variables
        let localStream = null;
        let videoElement = null;
        let canvasElement = null;
        let frameInterval = null;
        let overlayCanvas = null;
        let overlayCtx = null;
        
        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:8000/ws/surveillance');
            
            ws.onopen = () => {
                console.log('WebSocket connected');
                isConnected = true;
                updateConnectionStatus(true);
                document.getElementById('connectionError').style.display = 'none';
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected');
                isConnected = false;
                updateConnectionStatus(false);
                
                // Attempt to reconnect after 3 seconds
                setTimeout(() => {
                    if (!isConnected) {
                        document.getElementById('connectionError').style.display = 'block';
                        connectWebSocket();
                    }
                }, 3000);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
        }
        
        function handleWebSocketMessage(message) {
            switch (message.type) {
                case 'detection':
                    handleDetection(message.data);
                    break;
                case 'anomaly_alert':
                    handleAnomaly(message.data);
                    break;
                case 'stats':
                    updateStats(message.data);
                    break;
            }
        }
        
        function handleDetection(data) {
            // Add to detections list
            if (data.detections && data.detections.length > 0) {
                data.detections.forEach(detection => {
                    detections.unshift(detection);
                    if (detections.length > 20) detections.pop();
                });
                updateDetectionsList();
                
                // Draw bounding boxes
                drawBoundingBoxes(data.detections);
                
                // Update stats
                stats.totalDetections += data.detections.length;
                updateStatsDisplay();
            }
            
            // Update FPS display
            if (data.fps) {
                document.getElementById('fpsDisplay').textContent = data.fps.toFixed(1) + ' FPS';
            }
            
            // Handle anomalies
            if (data.anomalies && data.anomalies.length > 0) {
                data.anomalies.forEach(anomaly => {
                    handleAnomaly(anomaly);
                });
            }
            
            // Update tracking stats
            if (data.tracking_stats) {
                stats.totalVehicles = data.tracking_stats.total_vehicles_tracked || 0;
                updateStatsDisplay();
            }
        }
        
        function drawBoundingBoxes(detections) {
            if (!overlayCtx || !videoElement) return;
            
            // Clear previous boxes
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            // Get video dimensions
            const videoWidth = videoElement.videoWidth;
            const videoHeight = videoElement.videoHeight;
            
            if (!videoWidth || !videoHeight) return;
            
            // Calculate scale factors
            const scaleX = overlayCanvas.width / videoWidth;
            const scaleY = overlayCanvas.height / videoHeight;
            
            detections.forEach(detection => {
                if (detection.box && detection.box.length === 4) {
                    const [x1, y1, x2, y2] = detection.box;
                    
                    // Scale coordinates
                    const scaledX = x1 * scaleX;
                    const scaledY = y1 * scaleY;
                    const scaledWidth = (x2 - x1) * scaleX;
                    const scaledHeight = (y2 - y1) * scaleY;
                    
                    // Set style based on confidence
                    const confidence = detection.confidence;
                    let strokeColor = '#10b981'; // green
                    if (confidence < 0.5) strokeColor = '#ef4444'; // red
                    else if (confidence < 0.8) strokeColor = '#f59e0b'; // yellow
                    
                    // Draw box
                    overlayCtx.strokeStyle = strokeColor;
                    overlayCtx.lineWidth = 2;
                    overlayCtx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
                    
                    // Draw label
                    const label = `${detection.plate_text} (${(confidence * 100).toFixed(0)}%)`;
                    overlayCtx.fillStyle = strokeColor;
                    overlayCtx.fillRect(scaledX, scaledY - 20, label.length * 8, 20);
                    
                    overlayCtx.fillStyle = 'white';
                    overlayCtx.font = '14px Arial';
                    overlayCtx.fillText(label, scaledX + 4, scaledY - 6);
                }
            });
            
            // Clear boxes after 2 seconds
            setTimeout(() => {
                if (overlayCtx) {
                    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                }
            }, 2000);
        }
        
function handleAnomaly(anomaly) {
    // Special handling for no-plate vehicles
    if (anomaly.type === 'NO_PLATE_VEHICLE' || anomaly.type === 'SUSPICIOUS_NO_PLATE') {
        // Add special visual/audio alert
        const alertContainer = document.getElementById('alertsList');
        const specialAlert = document.createElement('div');
        specialAlert.className = 'no-plate-alert';
        specialAlert.innerHTML = `
            <div style="display: flex; align-items: center; gap: 1rem;">
                <div style="font-size: 2rem;">‚ö†Ô∏è</div>
                <div>
                    <div style="font-weight: bold; font-size: 1.1rem;">VEHICLE WITHOUT LICENSE PLATE</div>
                    <div>Time: ${formatTime(anomaly.timestamp || new Date().toISOString())}</div>
                    ${anomaly.details && anomaly.details.vehicle_attributes ? 
                        `<div>Vehicle: ${getVehicleDescription(anomaly.details.vehicle_attributes)}</div>` : ''}
                </div>
            </div>
        `;
        alertContainer.insertBefore(specialAlert, alertContainer.firstChild);
        
        // Play more urgent sound
        playUrgentAlert();
        
        // Flash the screen
        flashScreen();
        
        // Remove the special alert after 30 seconds
        setTimeout(() => {
            specialAlert.style.transition = 'opacity 1s';
            specialAlert.style.opacity = '0';
            setTimeout(() => specialAlert.remove(), 1000);
        }, 30000);
    }
    
    // Continue with normal anomaly handling
    alerts.unshift({
        ...anomaly,
        timestamp: anomaly.timestamp || new Date().toISOString()
    });
    if (alerts.length > 50) alerts.pop();
    
    stats.alertsToday++;
    updateAlertsList();
    updateStatsDisplay();
    
    // Play alert sound for high severity
    if (anomaly.severity === 'high' || anomaly.severity === 'critical') {
        playAlertSound();
    }
}

function getVehicleDescription(attributes) {
    const parts = [];
    if (attributes.color) parts.push(attributes.color);
    if (attributes.year) parts.push(attributes.year);
    if (attributes.make) parts.push(attributes.make);
    if (attributes.model) parts.push(attributes.model);
    if (attributes.type) parts.push(`(${attributes.type})`);
    
    return parts.join(' ') || 'Unknown Vehicle';
}

function flashScreen() {
    const flash = document.createElement('div');
    flash.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 0, 0, 0.3);
        z-index: 9999;
        pointer-events: none;
        animation: flash 0.5s ease-in-out;
    `;
    
    const style = document.createElement('style');
    style.textContent = `
        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }
    `;
    document.head.appendChild(style);
    document.body.appendChild(flash);
    
    setTimeout(() => {
        flash.remove();
        style.remove();
    }, 500);
}

function playUrgentAlert() {
    // More urgent alert sound for no-plate vehicles
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Play 3 beeps with increasing frequency
    for (let i = 0; i < 3; i++) {
        setTimeout(() => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800 + (i * 200); // Increasing frequency
            gainNode.gain.value = 0.3;
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.2);
        }, i * 300);
    }
}

// Add a new section for no-plate vehicles in the stats
function updateStatsDisplay() {
    document.getElementById('totalVehicles').textContent = stats.totalVehicles;
    document.getElementById('totalDetections').textContent = stats.totalDetections;
    document.getElementById('alertsToday').textContent = stats.alertsToday;
    
    // Count no-plate alerts
    const noPlateCount = alerts.filter(a => 
        a.type === 'NO_PLATE_VEHICLE' || a.type === 'SUSPICIOUS_NO_PLATE'
    ).length;
    
    // Update or create no-plate stat
    let noPlateStatEl = document.getElementById('noPlateVehicles');
    if (!noPlateStatEl) {
        // Create new stat element
        const statsGrid = document.querySelector('.stats-grid');
        const statItem = document.createElement('div');
        statItem.className = 'stat-item';
        statItem.innerHTML = `
            <div class="stat-value" id="noPlateVehicles" style="color: #ef4444;">${noPlateCount}</div>
            <div class="stat-label">No-Plate Vehicles</div>
        `;
        statsGrid.appendChild(statItem);
    } else {
        noPlateStatEl.textContent = noPlateCount;
    }
    
    if (detections.length > 0) {
        const avgConf = detections.reduce((sum, d) => sum + d.confidence, 0) / detections.length;
        document.getElementById('avgConfidence').textContent = (avgConf * 100).toFixed(0) + '%';
    }
}

// Add CSS for the new alert styles
const additionalStyles = `
    <style>
    .no-plate-alert {
        background: #dc3545;
        color: white;
        padding: 1rem;
        margin-bottom: 1rem;
        border-radius: 8px;
        font-weight: 600;
        animation: pulse 2s infinite, slideIn 0.5s ease;
        box-shadow: 0 4px 20px rgba(220, 53, 69, 0.5);
    }
    
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.02); }
        100% { transform: scale(1); }
    }
    
    .detection-item.no-plate {
        border: 2px solid #ef4444;
        background: rgba(239, 68, 68, 0.1);
    }
    
    .vehicle-box {
        position: absolute;
        border: 2px solid #f59e0b;
        background: rgba(245, 158, 11, 0.1);
        transition: all 0.3s ease;
    }
    
    .vehicle-label {
        position: absolute;
        top: -25px;
        left: 0;
        background: #f59e0b;
        color: #000;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: 600;
        white-space: nowrap;
    }
    </style>
`;

// Add the styles to the document
document.head.insertAdjacentHTML('beforeend', additionalStyles);

function playUrgentAlert() {
    // More urgent alert sound for no-plate vehicles
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Play 3 beeps
    for (let i = 0; i < 3; i++) {
        setTimeout(() => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 1000; // Higher frequency
            gainNode.gain.value = 0.2;
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.2);
        }, i * 300);
    }
}
        
        function updateDetectionsList() {
            const container = document.getElementById('detectionsList');
            document.getElementById('detectionCount').textContent = detections.length;
            
            container.innerHTML = detections.map(detection => `
                <div class="detection-item">
                    <img src="data:image/jpeg;base64,${detection.plate_image_base64}" 
                         class="detection-image" alt="Plate">
                    <div class="detection-info">
                        <div class="plate-text">${detection.plate_text}</div>
                        <div class="confidence">Confidence: ${(detection.confidence * 100).toFixed(1)}%</div>
                        ${detection.state ? `<div class="confidence">State: ${detection.state}</div>` : ''}
                    </div>
                </div>
            `).join('');
        }
        
        function updateAlertsList() {
            const container = document.getElementById('alertsList');
            document.getElementById('alertCount').textContent = alerts.length;
            
            container.innerHTML = alerts.map(alert => `
                <div class="alert-item ${alert.severity}">
                    <div class="alert-header">
                        <span class="alert-type">${alert.type}</span>
                        <span class="alert-time">${formatTime(alert.timestamp)}</span>
                    </div>
                    <div>${alert.message}</div>
                    ${alert.plate ? `<div><strong>Plate:</strong> ${alert.plate}</div>` : ''}
                </div>
            `).join('');
        }
        
        function updateStatsDisplay() {
            document.getElementById('totalVehicles').textContent = stats.totalVehicles;
            document.getElementById('totalDetections').textContent = stats.totalDetections;
            document.getElementById('alertsToday').textContent = stats.alertsToday;
            
            if (detections.length > 0) {
                const avgConf = detections.reduce((sum, d) => sum + d.confidence, 0) / detections.length;
                document.getElementById('avgConfidence').textContent = (avgConf * 100).toFixed(0) + '%';
            }
        }
        
        function updateConnectionStatus(connected) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                statusDot.classList.remove('inactive');
                statusDot.classList.add('active');
                statusText.textContent = 'Connected';
            } else {
                statusDot.classList.remove('active');
                statusDot.classList.add('inactive');
                statusText.textContent = 'Disconnected';
            }
        }
        
        async function startSurveillance() {
            try {
                // First, start the backend surveillance processor
                const response = await fetch('/api/v1/surveillance/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ video_source: 'browser_stream' })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to start surveillance backend');
                }
                
                // Now start browser camera
                await startBrowserCamera();
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
            } catch (error) {
                console.error('Error starting surveillance:', error);
                alert('Error starting surveillance: ' + error.message);
            }
        }
        
        async function startBrowserCamera() {
            try {
                console.log('Starting browser camera...');
                
                // Get video element and create canvas
                videoElement = document.getElementById('videoFeed');
                overlayCanvas = document.getElementById('overlayCanvas');
                overlayCtx = overlayCanvas.getContext('2d');
                
                // Create hidden canvas for frame capture
                canvasElement = document.createElement('canvas');
                canvasElement.width = 1280;
                canvasElement.height = 720;
                
                // Always enumerate devices fresh
                console.log('Enumerating cameras...');
                const videoDevices = await enumerateCameras();
                
                if (videoDevices.length === 0) {
                    throw new Error('No camera devices found. Please ensure a camera is connected and permissions are granted.');
                }
                
                // Get selected camera
                let videoSource = document.getElementById('videoSource').value;
                console.log('Selected video source:', videoSource);
                
                // Build constraints
                let constraints = {
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                };
                
                // Only add deviceId if we have a specific one
                if (videoSource && videoSource !== '' && videoSource !== 'none') {
                    constraints.video.deviceId = { exact: videoSource };
                    console.log('Using specific device:', videoSource);
                }
                
                console.log('Requesting getUserMedia with constraints:', constraints);
                
                try {
                    localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('Got stream successfully!');
                } catch (err) {
                    console.error('getUserMedia failed with constraints:', err);
                    
                    // If specific device failed, try without deviceId
                    if (videoSource) {
                        console.log('Retrying without specific deviceId...');
                        constraints = {
                            video: {
                                width: { ideal: 1280 },
                                height: { ideal: 720 }
                            },
                            audio: false
                        };
                        localStream = await navigator.mediaDevices.getUserMedia(constraints);
                        console.log('Got stream with default device!');
                    } else {
                        throw err;
                    }
                }
                
                console.log('Stream tracks:', localStream.getTracks().map(t => ({
                    kind: t.kind,
                    label: t.label,
                    id: t.id,
                    enabled: t.enabled,
                    readyState: t.readyState
                })));
                
                videoElement.srcObject = localStream;
                
                // Setup overlay canvas when video loads
                videoElement.onloadedmetadata = () => {
                    console.log('Video metadata loaded');
                    overlayCanvas.width = videoElement.videoWidth;
                    overlayCanvas.height = videoElement.videoHeight;
                };
                
                // Hide the no video message
                document.getElementById('noVideo').style.display = 'none';
                videoElement.style.display = 'block';
                
                // Start sending frames to backend
                startFrameCapture();
                console.log('Camera started successfully!');
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                console.error('Error constraint:', error.constraint);
                
                let errorMessage = '‚ö†Ô∏è Camera access error: ' + error.message;
                
                if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage = '‚ö†Ô∏è No camera found. Please:\n1. Connect a camera\n2. Allow camera permissions in browser\n3. Check if camera works in other apps';
                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage = '‚ö†Ô∏è Camera access denied. Click the camera icon in the address bar to allow permissions.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage = '‚ö†Ô∏è Camera is being used by another application. Close other apps using the camera.';
                } else if (error.name === 'OverconstrainedError') {
                    errorMessage = '‚ö†Ô∏è Camera does not support requested settings.';
                }
                
                document.getElementById('noVideo').innerHTML = errorMessage.replace(/\n/g, '<br>');
                document.getElementById('noVideo').style.display = 'block';
                throw error;
            }
        }
        
        async function enumerateCameras() {
            try {
                console.log('Enumerating cameras - requesting permissions first...');
                
                // First, enumerate without permissions to see what we get
                let devices = await navigator.mediaDevices.enumerateDevices();
                console.log('Initial enumeration:', devices);
                
                // Check if we have any video devices without labels (indicates no permission)
                const unlabeledVideo = devices.filter(d => d.kind === 'videoinput' && !d.label);
                if (unlabeledVideo.length > 0 || devices.filter(d => d.kind === 'videoinput').length === 0) {
                    console.log('No video devices or unlabeled devices found, requesting camera permission...');
                    
                    try {
                        // Request camera permission
                        const tempStream = await navigator.mediaDevices.getUserMedia({ 
                            video: true,
                            audio: false 
                        });
                        console.log('Got camera permission, cleaning up temp stream...');
                        tempStream.getTracks().forEach(track => {
                            track.stop();
                            console.log('Stopped track:', track.label);
                        });
                        
                        // Re-enumerate after getting permission
                        devices = await navigator.mediaDevices.enumerateDevices();
                        console.log('Post-permission enumeration:', devices);
                    } catch (permError) {
                        console.error('Failed to get camera permission:', permError);
                    }
                }
                
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                console.log('Found video devices:', videoDevices);
                
                const videoSelect = document.getElementById('videoSource');
                const currentSelection = videoSelect.value;
                
                videoSelect.innerHTML = '';
                
                // Always add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.text = 'Default Camera';
                videoSelect.appendChild(defaultOption);
                
                if (videoDevices.length === 0) {
                    console.warn('No video devices found!');
                    const noDeviceOption = document.createElement('option');
                    noDeviceOption.value = 'none';
                    noDeviceOption.text = 'No cameras found';
                    noDeviceOption.disabled = true;
                    videoSelect.appendChild(noDeviceOption);
                } else {
                    videoDevices.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `Camera ${index + 1} (${device.deviceId.substring(0, 8)}...)`;
                        videoSelect.appendChild(option);
                        console.log(`Added camera option: ${option.text}`);
                    });
                }
                
                // Try to restore previous selection if it still exists
                if (currentSelection && currentSelection !== '0') {
                    videoSelect.value = currentSelection;
                }
                
                return videoDevices;
                
            } catch (error) {
                console.error('Error enumerating cameras:', error);
                return [];
            }
        }
        
        function startFrameCapture() {
            if (frameInterval) {
                clearInterval(frameInterval);
            }
            
            const ctx = canvasElement.getContext('2d');
            let frameCount = 0;
            let lastFrameTime = Date.now();
            let fps = 0;
            
            // Send frames every 500ms (2 FPS) to avoid overwhelming the backend
            frameInterval = setInterval(async () => {
                if (!videoElement || videoElement.paused || videoElement.ended) {
                    return;
                }
                
                frameCount++;
                
                // Calculate FPS
                const currentTime = Date.now();
                const timeDiff = currentTime - lastFrameTime;
                if (timeDiff > 0) {
                    fps = 1000 / timeDiff;
                    document.getElementById('fpsDisplay').textContent = fps.toFixed(1) + ' FPS';
                }
                lastFrameTime = currentTime;
                
                try {
                    // Draw current video frame to canvas
                    ctx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                    
                    // Convert to blob
                    canvasElement.toBlob(async (blob) => {
                        if (!blob) return;
                        
                        // Send to backend for processing
                        const formData = new FormData();
                        formData.append('frame', blob, 'frame.jpg');
                        formData.append('frame_id', frameCount.toString());
                        
                        try {
                            const response = await fetch('/api/v1/surveillance/process-frame', {
                                method: 'POST',
                                body: formData
                            });
                            
                            if (response.ok) {
                                const result = await response.json();
                                // Detection results will come through WebSocket
                            }
                        } catch (error) {
                            console.error('Error sending frame:', error);
                        }
                    }, 'image/jpeg', 0.8);
                    
                } catch (error) {
                    console.error('Error capturing frame:', error);
                }
            }, 500); // 2 FPS
        }
        
        async function stopSurveillance() {
            try {
                // Stop frame capture
                if (frameInterval) {
                    clearInterval(frameInterval);
                    frameInterval = null;
                }
                
                // Stop camera stream properly
                if (localStream) {
                    localStream.getTracks().forEach(track => {
                        track.stop();
                        // Ensure track is fully stopped
                        track.enabled = false;
                    });
                    localStream = null;
                }
                
                // Clear video element
                if (videoElement) {
                    videoElement.srcObject = null;
                    videoElement.onloadedmetadata = null;
                    videoElement.style.display = 'none';
                }
                
                // Clear overlay
                if (overlayCtx) {
                    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                }
                
                // Show no video message
                document.getElementById('noVideo').style.display = 'block';
                document.getElementById('noVideo').textContent = 'üìπ Click "Start Surveillance" to begin monitoring';
                
                // Stop backend processing
                const response = await fetch('/api/v1/surveillance/stop', {
                    method: 'POST'
                });
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                
                // Clear FPS display
                document.getElementById('fpsDisplay').textContent = '0.0 FPS';
                
                // Reset camera selection to default
                document.getElementById('videoSource').selectedIndex = 0;
                
                // Small delay to ensure resources are released
                await new Promise(resolve => setTimeout(resolve, 500));
                
            } catch (error) {
                console.error('Error stopping surveillance:', error);
            }
        }
        
        async function resetCameraPermissions() {
            console.log('Resetting camera permissions...');
            
            // Stop any existing streams
            if (localStream) {
                await stopSurveillance();
            }
            
            // Clear the select
            document.getElementById('videoSource').innerHTML = '<option value="0">Default Camera</option>';
            
            // Try to get fresh permissions
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(track => track.stop());
                console.log('Camera permissions reset successfully');
                
                // Re-enumerate cameras
                await enumerateCameras();
                
                alert('Camera permissions reset! Try starting surveillance again.');
            } catch (error) {
                console.error('Error resetting permissions:', error);
                alert('Error accessing camera. Please check:\n1. Camera is connected\n2. No other apps are using the camera\n3. Browser has camera permissions');
            }
        }
        
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString();
        }
        
        function playAlertSound() {
            // Create a simple beep sound
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            gainNode.gain.value = 0.1;
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', async () => {
            connectWebSocket();
            
            // Enumerate cameras on load
            await enumerateCameras();
            
            // Add camera change event listener
            document.getElementById('videoSource').addEventListener('change', async () => {
                // If surveillance is running, restart with new camera
                if (localStream) {
                    console.log('Camera changed, restarting stream...');
                    await stopSurveillance();
                    await startSurveillance();
                }
            });
            
            // Check initial status
            fetch('/api/v1/surveillance/status')
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'running') {
                        document.getElementById('startBtn').disabled = true;
                        document.getElementById('stopBtn').disabled = false;
                    }
                });
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (ws) ws.close();
            stopSurveillance();
        });
    </script>
</body>
</html>